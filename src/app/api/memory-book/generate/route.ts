/**
 * Memory Book PDF Generation API
 *
 * POST /api/memory-book/generate
 *
 * Generates a PDF memory book from the provided configuration.
 * The PDF is generated server-side and can be returned as a blob
 * or stored in Supabase storage.
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseSSR } from '@/lib/supabase/server-ssr';
import { logAudit } from '@/lib/audit/logger';
import type { BookConfig, BookGenerationResult } from '@/lib/memory-book/types';

// Dynamic import for react-pdf (only on server)
async function generatePdf(config: BookConfig): Promise<Buffer> {
  // Import react-pdf renderer dynamically
  const { renderToBuffer } = await import('@react-pdf/renderer');
  const { MemoryBookDocument } = await import('@/lib/memory-book/pdf-generator');
  const React = await import('react');

  // Create the document element
  const document = React.createElement(MemoryBookDocument, { config });

  // Render to buffer
  const buffer = await renderToBuffer(document as any);

  return Buffer.from(buffer);
}

export async function POST(req: NextRequest) {
  try {
    const supabase = await getSupabaseSSR();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get user profile for the generated by field
    const { data: profile } = await supabase
      .from('persons')
      .select('first_name, last_name')
      .eq('id', user.id)
      .single() as { data: { first_name: string; last_name: string } | null };

    const userName = profile
      ? `${profile.first_name} ${profile.last_name}`
      : 'Unknown User';

    // Parse request body
    const body = await req.json();
    const { config, saveToStorage = false } = body as {
      config: Partial<BookConfig>;
      saveToStorage?: boolean;
    };

    // Validate required fields
    if (!config.title) {
      return NextResponse.json(
        { error: 'Book title is required' },
        { status: 400 }
      );
    }

    // Build complete config with defaults
    const fullConfig: BookConfig = {
      title: config.title,
      subtitle: config.subtitle,
      coverImageUrl: config.coverImageUrl,
      dedication: config.dedication,
      theme: config.theme || 'classic',
      pageSize: config.pageSize || 'A4',
      orientation: config.orientation || 'portrait',
      selectedPeople: config.selectedPeople || [],
      selectedStories: config.selectedStories || [],
      selectedPhotos: config.selectedPhotos || [],
      sections: config.sections || [],
      includeTableOfContents: config.includeTableOfContents ?? true,
      includePageNumbers: config.includePageNumbers ?? true,
      includeDateGenerated: config.includeDateGenerated ?? true,
      generatedBy: {
        userId: user.id,
        userName,
      },
      familyId: config.familyId,
    };

    // Generate the PDF
    const pdfBuffer = await generatePdf(fullConfig);

    // Log the generation
    await logAudit({
      action: 'GENERATE_MEMORY_BOOK',
      entityType: 'memory_book',
      entityId: undefined,
      requestBody: {
        title: fullConfig.title,
        theme: fullConfig.theme,
        peopleCount: fullConfig.selectedPeople.length,
        storiesCount: fullConfig.selectedStories.length,
        photosCount: fullConfig.selectedPhotos.length,
      } as any,
    });

    // Option to save to Supabase storage
    if (saveToStorage) {
      const fileName = `memory-books/${user.id}/${Date.now()}-${fullConfig.title.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.pdf`;

      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('media')
        .upload(fileName, pdfBuffer, {
          contentType: 'application/pdf',
          cacheControl: '3600',
        });

      if (uploadError) {
        console.error('Error uploading PDF to storage:', uploadError);
        // Still return the PDF even if storage fails
      } else {
        // Get public URL
        const {
          data: { publicUrl },
        } = supabase.storage.from('media').getPublicUrl(fileName);

        const result: BookGenerationResult = {
          success: true,
          pdfUrl: publicUrl,
          generatedAt: new Date().toISOString(),
        };

        return NextResponse.json(result);
      }
    }

    // Return PDF as blob response
    return new NextResponse(new Uint8Array(pdfBuffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${fullConfig.title.replace(/[^a-z0-9]/gi, '-')}-memory-book.pdf"`,
        'Content-Length': pdfBuffer.length.toString(),
      },
    });
  } catch (error: any) {
    console.error('Error generating memory book:', error);

    // Check for specific react-pdf errors
    if (error.message?.includes('@react-pdf/renderer')) {
      return NextResponse.json(
        {
          error: 'PDF generation library not installed. Please run: npm install @react-pdf/renderer',
          details: error.message,
        },
        { status: 500 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to generate memory book', details: error.message },
      { status: 500 }
    );
  }
}

// GET endpoint to check if the feature is available
export async function GET() {
  try {
    // Try to import react-pdf to check if it's installed
    await import('@react-pdf/renderer');

    return NextResponse.json({
      available: true,
      message: 'Memory Book PDF generation is available',
    });
  } catch {
    return NextResponse.json({
      available: false,
      message: 'Memory Book PDF generation requires @react-pdf/renderer to be installed',
      installCommand: 'npm install @react-pdf/renderer',
    });
  }
}
